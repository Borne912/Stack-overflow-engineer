#include <stdio.h>

int main(int argc, char const *argv[])
{
	/**
	 * 题目内容：
	 * 由于计算机内部表达方式的限制，浮点运算都有精度问题，为了得到高精度的计算结果，就需要自己设计实现方法。
	 * (0,1)之间的任何浮点数都可以表达为两个正整数的商，为了表达这样两个数的商，可以将相除的结果以多个整数来表示，每个整数表示结果的一位。
	 * 即商的第一位用一个整数来表示，第二位用另一个整数来表示，以此类推，就可以输出一个高精度的除法结果了。
	 * 如16/19的结果0.8421052631...就可以依次输出8、4、2、1、0、5、2、6、3、1...。
	 * 而除法的过程，则可以模仿人工列竖式做除法的方式，先将被除数乘以10，得到一位商以后，将余数乘以10作为下一轮计算的被除数：
	 *
	 * 160/19->8余8
	 *
	 * 80/19->4余4
	 * ...
	 * 当某次余数为0时，则表明除尽。
	 * 现在，请写一个程序，输入一个分数，计算出它的小数形式。无论是否可以除尽，输出最多小数点后200位。
	 *
	 * 输入格式：
	 * 形如
	 *     a/b
	 * 的两个数，其中10<=a<b<100。也就是说，这个小数一定是小于1的正数。
	 *
	 * 提示：输入是带着两个数中间的“/”的，所以scanf应采用“%d/%d”这样的输入格式。
	 *
	 * 输出格式：
	 * 形如
	 *   0.xxxxxxxxx
	 * 的小数，小数点后最多200位。输出结束的时候要带着回车换行。如果a/b是一个有限不循环小数，则输出完所有的有效位就可以了，不需要再输出后面的0来凑满200位。
	 *
	 * 有限循环小数：
	 * 16/19 -> 16*10/19 -> 160/19 -> 8 余 8
	 * 8/19  -> 8*10/19 -> 80/19 -> 4 余 4
	 * 4/19 -> 4*10/19 -> 40/19 -> 2 余 2
	 * 2/19 -> 2*10/19 -> 20/19 -> 1 余 1
	 * 1/19 -> 1*10/19 -> 10/19 -> 0 余 10
	 * 10/19 -> 10*10/19 -> 100/19 -> 5 余 5
	 * ······
	 * 有限不循环小数：
	 * 4/5 -> 4*10/5 -> 40/5 -> 8 余 0
	 */

	int a = 0, b = 0;

	scanf("%d/%d", &a, &b);

	int remainder = 0; // 余数

	const int count = 200; // 输出200位小数

	int decimals[count];

	// 数组赋初值

	for (int i = 0; i < count; ++i)
	{
		decimals[i] = 0;
	}

	int i = 0; // 存储decimals的有效位数
	for (i = 0; i < count; ++i)
	{
		a = a * 10;
		decimals[i] = a / b;
		remainder = a % b;
		a = remainder;
		if (a == 0) // 有限不循环
		{
			break;
			i++; // 当通过break跳出循环时，i为decimals数组的长度减1；而不通过break跳出循环（即：等到i=200）时，i为decimals数组的长度，i++是为了统一两者
		}
	}

	printf("0.");

	for (int j = 0; j < i; ++j)
	{
		printf("%d", decimals[j]);
	}
	return 0;
}